# Getting Started

`InferAPP` streamlines the use of inference models by encapsulating the inference functions in a user-friendly framework. It provides easy-to-configure input and output strategies tailored to the processing and production of AiCOCO-formatted data, ensuring seamless integration and standardization.

## Step 0: About POST `/invocations`

### Request

#### Header

```content-type: multipart/form-data
```

#### Body

- `files`:  Image files.
- `images`: Refer to **AiCOCO** format.

## Step 1: Wrap your callback function

### InferAPP

Wrap the inference function of your model with the class `InferAPP` and optionally specify the input and output strategy functions.

### Input strategy

The input strategy function converts the API input into the desired format. The standard input strategy function can be found under `AiCOCOInputStrategy`.

### Output strategy

The output strategy function converts the model output into an AiCOCO-compatible format. Depending on the task, there are four standard output strategy functions to choose from: `AiCOCOClassificationOutputStrategy`, `AiCOCODetectionOutputStrategy`, `AiCOCORegressionOutputStrategy` and `AiCOCOSegmentationOutputStrategy`.

### Example of a segmentation task (PyTorch)

```python
from flavor.serve.apps import InferAPP
from flavor.serve.strategies import AiCOCOInputStrategy, AiCOCOSegmentationOutputStrategy

# Define the infer function for your model
def infer(**kwargs):

    # Your model & inference code
    ...

    # Please return your output as defined in README
    result = {
        "sorted_images": [
            {"id": "TZsN5Td8LunFEdL8o8334", "file_name": "slice0.dcm", "index": 0, ...},
            {"id": "tF410qthYoQ5t7qnK2RcR", "file_name": "slice1.dcm", "index": 1, ...},
            ...
        ],
        "categories": {
            0: {"name": "Background", "supercategory_name": "Tumor", "display": False},
            1: {"name": "Lesion", "supercategory_name": "Tumor", "display": True},
            ...
        },
        "regressions": {},
        "model_out": model_out,
    }

    return result

# Wrap the infer function with input and optional output strategies
app = InferAPP(infer_function=infer,
               input_strategy=AiCOCOInputStrategy,
               output_strategy=AiCOCOSegmentationOutputStrategy)

# Start the application
app.run(port=9000)
```

### Input structures

`AiCOCOInputStrategy`: This strategy parses the incoming data into a structured format that the inference function can interpret. More specifically, `AiCOCOInputStrategy` adds the `physical_file_name` to the input.

#### Input format example

```python
{
    "images": [
        # can be without order
        {
            "id": "nanoid",
            "index": index,
            "file_name": "<filename>.<ext>",
            "physical_file_name": "<filename>.<ext>", # The actual location of the file, generated by AiCOCOInputStrategy
            ...
        },
        ...
    ]
}
```

### Output structures

The output strategy is an optional component that allows the output of the inference model to be easily converted to AiCOCO format and provides a standardized method for serializing the results. If `output_strategy=None` is specified, the `infer_function` must return the AiCOCO format directly.

The given output strategy can be chosen depending on the task, classification, detection, regression or segmentation. Each requires a different input format, which is defined in `AiCOCOClassificationOutputStrategy`, `AiCOCODetectionOutputStrategy`, `AiCOCORegressionOutputStrategy` and `AiCOCOSegmentationOutputStrategy`.

The inputs for each task are listed as follows:

- **Classification task** -  `AiCOCOClassificationOutputStrategy`:

```python
output = {
    "sorted_images": [{"id": uid, "file_name": file_name, "index": index, ...}, ...],
    "categories": {class_id: {"name": category_name, "supercategory_name": supercategory_name, display: True, ...}, ...},
    "regressions": {},
    "model_out": model_out # 1d NumPy array with classification predictions
}
```

- **Detection task** - `AiCOCODetectionOutputStrategy`:

```python
output = {
    "sorted_images": [{"id": uid, "file_name": file_name, "index": index, ...}, ...],
    "categories": {class_id: {"name": category_name, "supercategory_name": supercategory_name, display: True, ...}, ...},
    "regressions": {regression_id: {"name": regression_name, "superregression_name": superregression_name, ...}, ...},
    "model_out": {
        "bbox_pred": bbox_pred, # list of bbox prediction as [[x_min, y_min, x_max, y_max], ...]
        "cls_pred": cls_pred, # list of classification result of each bbox
        "confidence_score": confidence_score, # optional, list of the confidence values of the individual bboxes
        "regression_value": regression_value, # optional, list of the regression value of each bbox if there is a regression prediction
    }
}
```

- **Regression task** - `AiCOCORegressionOutputStrategy`:

```python
output = {
    "sorted_images": [{"id": uid, "file_name": file_name, "index": index, ...}, ...],
    "categories": {},
    "regressions": {regression_id: {"name": regression_name, "superregression_name": superregression_name, ...}, ...},
    "model_out": model_out # 1d NumPy array with regression predictions
}
```

- **Segmentation task** - `AiCOCOSegmentationOutputStrategy`:

```python
output = {
    "sorted_images": [{"id": uid, "file_name": file_name, "index": index, ...}, ...],
    "categories": {class_id: {"name": category_name, "supercategory_name": supercategory_name, display: True, ...}, ...},
    "regressions": {},
    "model_out": model_out # 4d NumPy array with grouped segmentation predictions
}
```

The general pattern of expected output should be a dictionary containing the following keys:

- `sorted_images`: a list of AiCOCO-compatible images (see input format) sorted by a certain criterion (e.g. by Z-axis or temporal order) to correlate with `model_out`.

- `categories`: a dictionary where each key is the class ID. The corresponding value is a dictionary of category information that must be filled with `supercategory_name`, `display` and all necessary details as described in the AiCOCO format, except for the fields related to "nanoid".

- `regressions`: a dictionary in which each key is the regression ID. The corresponding value is a dictionary with regression information that must be filled with `superregression_name` and all necessary details as described in the AiCOCO format, except for the fields related to "nanoid".

- `model_out`:
  - classification and regression task: classification or regression results in a 1D NumPy with shape of `(n,)`. For multi-head cases, simply concatenate outputs of each head and keep the order in `category_ids`.
  - detection task: detection results packed in a dictionary containing key-value pairs as following:
    - `"bbox_pred"`: a list of bbox prediction. For example, ```[[x_min, y_min, x_max, y_max], ...]```
    - `"cls_pred"`: a list of classification result of each bbox.
    - `"confidence_score"`: (optional) a list of confidence score of each bbox.
    - `"regression_value"`: (optional) a list of regression value of each bbox
  - segmentation task: segmentation results in a 4D NumPy array with shape of `(c, z, y, x)`. For semantic segmentation, the values are binary (0 or 1) and indicate the presence of a class. For instance segmentation, the array contains instance IDs as positive integers that indicate different instances.

### AiCOCO format

The AiCOCO format is described in detail below and contains the [schema](../../schema/aicoco.json)  for structured output, including required and optional fields for `images`, `annotations`, `categories`, `regression` and `objects`.

```python
{
  "images": [
    {
      # Required fields
      "id": "nanoid(21)",
      "file_name": "<filename>.<ext>",
      # For order purpose
      "index": 1,
      "category_ids": [
        "nanoid(21)", ...
      ] or null,
      "regressions": [
        {
          "regression_id": "nanoid(21)",
          "value": 130
        }
        , ...
      ] or null,
      #  Optional fields
      ...
    }
  ],
  "annotations": [
    {
      # Required fields
      "id": "nanoid(21)",
      "image_id": "nanoid(21)",
      "object_id": "nanoid(21)",
      "iscrowd": 0, # 1 for RLE mask, 0 otherwise
      "bbox": [
        [
          x1, y1, x2, y2
        ],
        ...
      ] or null,
      "segmentation": [
        [
          x1, y1, x2, y2, x3, y3, ..., xn, yn
        ],
        ...
      ] or null,
      # Optional fields
      ...
    }
  ],
  "categories": [
    {
      # Required fields
      "id": "nanoid(21)",
      "name": "Brain",
      "supercategory_id": "nanoid(21)" or null,
      # Optional fields
      "color": "#FFFFFF",
      ...
    }
  ],
  "regressions": [
    {
      # Required fields
      "id": "nanoid(21)",
      "name": "SBP",
      "superregression_id": "nanoid(21)" or null,
      # Optional fields
      "unit": "mmHg",
      "threshold": "140",
      ...
    }
  ],
  "objects": [
    {
      # Required fields
      "id": "nanoid(21)",
      "category_ids": [
        "nanoid(21)", ...
      ] or null,
      "regressions": [
        {
          "regression_id": "nanoid(21)",
          "value": 130
        }
        , ...
      ] or null,
      # Optional fields
      "confidence": 0.5,
      ...
    }
  ],
  "meta": {
    # Required
    # For whole series label
    "category_ids": ["nanoid(21)", ...] or null,
    "regressions": [
        {
          "regression_id": "nanoid(21)",
          "value": 130
        }
        , ...
      ] or null,
    # Optional fields
    "task_type":  "binary" or "multiclass" or "multilabel",
    ...
  }
}

```

Replace all placeholders with actual values, e.g.  `<filename>.<ext>`, `nanoid`, and details under each JSON key.

## Step 2: Configure the Dockerfile Command

Package your code in a Docker image and set the `CMD` directive to run your application.

### Dockerfile Example

```dockerfile
CMD ["python", "main.py"]
```
